<div id="mdrose"></div>

<script type="text/javascript">

	function fakeData() {
		var result = {};
		result.dirs = [];
		result.sum = 500;  // this should be unnec.
		result.calm = { // this should also be unnec
			d: null,
			p: 5,
			s: null
		}
		for (var i=1; i < 13; i++) {
			result.dirs.push({
				d: i * 30,  // direction (degrees of the circle)
				p: 5, // this should be unnec
				s: i * i // size
			});
		}
		return result;
	}

	// Width of the whole visualization; used for centering
	var visWidth = 400;

//	drawBigMetadataRose(fakeData, vis, "Metadata Rose");
	drawBigMetadataRose(fakeData, "#mdrose", "Metadata Rose");


	function drawBigMetadataRose(mdroseData, container, captionText) {

		var r = visWidth / 2,  // radius of rose; also center pixel for rose width and height
			p = 20;  // center; probably broken if not square
			
		// The main SVG visualization element
		var viz = d3.select(container).append("svg:svg").attr("width", visWidth + "px").attr("height", (visWidth + 30) + "px");

		// Set up axes: circles whose radius represents quantity
		var tickrings = d3.range(0, 181, 20);
		var tickmarks = d3.range(20, 161, 40);
		var tickLabel = function(d) {
				return "" + d + " of 'em";
			}

		// Map a tickring to a radius for the chart
		var tickRadiusScale = d3.scale.linear().domain(tickrings).range(d3.range(0, 181, 20)).clamp(true);
		tickmarkRadiusScale = d3.scale.linear().domain(tickmarks).range(d3.range(20, 161, 40)).clamp(!0);
//		speedToRadiusScale = d3.scale.linear().domain([0, 20]).range([34, visWidth - 20]).clamp(!0),


		// Circles representing chart ticks
		viz.append("svg:g").attr("class", "axes").selectAll("circle").data(tickrings).enter().append("svg:circle").attr("stroke-width", 1).attr("stroke", "black").attr("fill-opacity", 0.0).attr("cx", r).attr("cy", r).attr("r", tickRadiusScale);

		// Text representing chart tickmarks
		viz.append("svg:g").attr("class", "tickmarks").selectAll("text").data(tickmarks).enter().append("svg:text").text(tickLabel).attr("dy", "-1px").attr("transform", function(d) {
			var y = visWidth - tickmarkRadiusScale(d);
			y = y - 200;
			return "translate(" + r + "," + y + ") "
		})
		
		// Labels: degree markers
		viz.append("svg:g").attr("class", "labels").selectAll("text").data(d3.range(30, 361, 30)).enter().append("svg:text").attr("dy", "-4px").attr("transform", function(d) {
			return "translate(" + r + "," + p + ") rotate(" + d + ",0," + (r - p) + ")"
		}).text(function(dir) {
			return dir;
		});

		// Labels:  metadata elements
//		var mdElements  = ['abstract', 'genre', 'name', 'language', 'identifier', 'note', 'originInfo', 'physicalDescription', 'subject', 'titleInfo', 'typeOfResource'];
//		viz.append("svg:g").attr("class", "labels").selectAll("text").data(d3.values(mdElements)).enter().append("svg:text").attr("dy", "-4px").attr("transform", function(mdroseData) {
//			return "translate(" + r + "," + p + ") rotate(" + mdroseData + ",0," + (r - p) + ")"
//		}).text(function(dir) {
//			return dir;
//		});



		// Map a value to a color
		var valToColorScale = d3.scale.linear().domain([5, 25]).range(["hsl(220, 70%, 90%)", "hsl(220, 70%, 30%)"]).interpolate(d3.interpolateHsl);
		function arcToColor(d) {
			return valToColorScale(d.s);
		}

		// Return a string representing d this datum
		function hoverText(d) {
//			return d.s.toFixed(0);
			return 'foo';
		};

		// Options for drawing the complex arc chart
		var mdroseArcOptions = {
			width: 5,
			from: 0,
	//		to: valToRadius
			to: 140
		}

		// Transformation to place a mark on top of an arc
		function arcTextT(d) {
//			var tr = valToRadius(d);
			var tr = d.s;
			return "translate(" + visWidth + "," + (visWidth - tr) + ")" + "rotate(" + d.d + ",0," + tr + ")";
		};

//		var rollup = rollupForMonths(mdroseData, selectedMonthControl.selected());
//		drawComplexArcs(vis, rollup, arcToColor, hoverText, mdroseArcOptions, arcTextT);
//		drawComplexArcs(vis, mdroseData, arcToColor, hoverText, mdroseArcOptions, arcTextT);
		drawMetadataArcs(viz, mdroseData, arcToColor, hoverText, mdroseArcOptions, arcTextT);

		viz.append("svg:text").text(captionText).attr("class", "caption").attr("transform", "translate(" + visWidth / 2 + "," + (visWidth + 20) + ")");
	}


	// Draw a complete metadata rose visualization, including axesÃ¥
	function drawMetadataArcs(parent, plotData, colorFunc, arcTextFunc, arcOptions, arcTextT) {
		// Draw the main rose arcs
//		parent.append("svg:g").attr("class", "arcs").selectAll("path").data(plotData.dirs).enter().append("svg:path").attr("d", arc(arcOptions)).style("fill", colorFunc).attr("transform", "translate(" + visWidth + "," + visWidth + ")").append("svg:title").text(function(d) {
		parent.append("svg:g").attr("class", "arcs").selectAll("path").data(fakeData.dirs).enter().append("svg:path").attr("d", arc(arcOptions)).style("fill", colorFunc).attr("transform", "translate(" + visWidth + "," + visWidth + ")").append("svg:title").text(function(d) {
//			return d.d + "\u00b0 " + d.s.toFixed(0)
			return "bar";
		});

		// Add the calm wind probability in the center
//		var cw = parent.append("svg:g").attr("class", "calmwind").selectAll("text").data([plotData.calm.p]).enter();
//		cw.append("svg:text").attr("transform", "translate(" + visWidth + "," + visWidth + ")").text(function(d) {
//			return Math.round(d * 100) + "%"
//		});
//		cw.append("svg:text").attr("transform", "translate(" + visWidth + "," + (visWidth + 14) + ")").attr("class", "calmcaption").text("calm");
	}



	// what the real data looks like
	var otherData = 
	{	"info":
		{	"lat":35.9381,
			"lon":-89.8319,
			"name":"BLYTHEVILLE MUNICIPAL AIRPORT","id":"KHKA"
		},
		"data":
		{	"3:270":[57,11.7],
			"8:300":[43,8.2],
			"5:130":[124,8.2],
			"1:60":[76,9.3],
			"9:10":[188,6.9],
			"8:60":[90,5.7],
			"6:350":[63,10.3],
			"4:70":[67,8.2],
			"11:null":[362,0.4],
		"12:230":[124,12.2]
		},
		"samples":52757
	}


	// a is hash with key = degree, value = amount
	// b is hash with key = degree, value = something bigger than amount
	function totalsToFrequenciesA(a, b) {
		// compute sum of all amounts
		var c = 0;
		for (var d in a) 
			c += a[d];
		c == 0 && (c = 1);
		var result = {};
		result.dirs = [];
		result.sum = c;
		for (var d in a) {
			var f = a[d] / c,	g;  // f is probability
			if (a[d] > 0)
				g = b[d] / a[d];  // i think this should be the second number in the parens for the data
			else // it was calm
				g = 0;
			d == "null"
			if (a[d] > 0 ? g = b[d] / a[d] : g = 0, d == "null")
				result.calm = {
					d: null,
					p: f,
					s: null
				}
			else 
				result.dirs.push({
					d: parseInt(d),
					p: f,
					s: g
				});
		}
		return result
	}

	function rollupForMonthsA(json_data, selected_month) {
		var c = {},	d = {};
		c["null"] = 0, d["null"] = 0;
		// something with degrees 
		for (var e = 10; e < 361; e += 10) 
			c["" + e] = 0, d["" + e] = 0;
			
		for (var f in json_data.data) {
			// f is   "3:270":[57,11.7]
			var g = f.split(":");
			
			if (g.length == 1) 
				var h = g[0];
			else 
				var i = g[0], //  month as number, e.g. 11 or 3
				h = g[1];  //  circle degrees as number, e.g.  130 or 270

			if (selected_month && !selected_month[i - 1]) 
				continue; // skip to next 
				
			// if   line is  "3:270":[57,11.7]
			c[h] += json_data.data[f][0];       //   c[270] =  57
			d[h] += json_data.data[f][0] * json_data.data[f][1]    //   d[270] = 57 * 11.7
		}
		return totalsToFrequencies(c, d)
	}





	// Function to draw a single arc for the metadata rose
	// Input: Drawing options object containing
	// width: degrees of width to draw (ie 5 or 15)
	// from: integer, inner radius
	// to: function returning the outer radius
	// Output: a function that when called, generates SVG paths.
	// It expects to be called via D3 with array of data objects
	//  with two parameters:
	// d: direction
	// s: size
	var arc = function(o) {
			return d3.svg.arc().startAngle(function(d) {
				return (d.d - o.width) * Math.PI / 180;
			}).endAngle(function(d) {
				return (d.d + o.width) * Math.PI / 180;
			}).innerRadius(o.from).outerRadius(function(d) {
				return o.to(d)
			});
		};

	// Map a value to an outer radius for the chart
	var valToRadiusScale = d3.scale.linear().domain([0, 20]).range([34, visWidth - 20]).clamp(true);

	function valToRadius(d) {
//		return valToRadiusScale(d.s);
//		return valToRadiusScale;
		return d.s;
	}









	// Convert a dictionary of {direction: total} to frequencies
	// Output is an array of objects with three parameters:
	// d: wind direction
	// p: probability of the wind being in this direction
	// s: average speed of the wind in this direction
	function totalsToFrequencies(totals, speeds) {
		var sum = 0;
		// Sum all the values in the dictionary
		for (var dir in totals) {
			sum += totals[dir];
		}
		if (sum == 0) { // total hack to work around the case where no months are selected
			sum = 1;
		}
		// Build up an object containing frequencies
		var ret = {};
		ret.dirs = []
		ret.sum = sum;
		for (var dir in totals) {
			var freq = totals[dir] / sum;
			var avgspeed;
			if (totals[dir] > 0) {
				avgspeed = speeds[dir] / totals[dir];
			} else {
				avgspeed = 0;
			}
			if (dir == "null") { // winds calm is a special case
				ret.calm = {
					d: null,
					p: freq,
					s: null
				};
			} else {
				ret.dirs.push({
					d: parseInt(dir),
					p: freq,
					s: avgspeed
				});
			}
		}
		return ret;
	}

	// Filter input data, giving back frequencies for the selected month
	function rollupForMonths(d, months) {
		var totals = {},
			speeds = {};
		for (var i = 10; i < 361; i += 10) {
			totals["" + i] = 0;
			speeds["" + i] = 0
		}
		totals["null"] = 0;
		speeds["null"] = 0;
		for (var key in d.data) {
			var s = key.split(":")
			if (s.length == 1) {
				var direction = s[0];
			} else {
				var month = s[0];
				var direction = s[1];
			}
			if (months && !months[month - 1]) {
				continue;
			}
			// count up all samples with this key
			totals[direction] += d.data[key][0];
			// add in the average speed * count from this key
			speeds[direction] += d.data[key][0] * d.data[key][1];
		}
		return totalsToFrequencies(totals, speeds);
	}

	/** Code for big visualization **/

	// Transformation to place a mark on top of an arc
	function probArcTextT(d) {
		var tr = probabilityToRadius(d);
		return "translate(" + visWidth + "," + (visWidth - tr) + ")" + "rotate(" + d.d + ",0," + tr + ")";
	};

	function speedArcTextT(d) {
		var tr = speedToRadius(d);
		return "translate(" + visWidth + "," + (visWidth - tr) + ")" + "rotate(" + d.d + ",0," + tr + ")";
	};

	// Return a string representing the wind speed for this datum
	function speedText(d) {
		return d.s < 10 ? "" : d.s.toFixed(0);
	};
	// Return a string representing the probability of wind coming from this direction
	function probabilityText(d) {
		return d.p < 0.02 ? "" : (100 * d.p).toFixed(0);
	};

	// Map a wind speed to a color
	var speedToColorScale = d3.scale.linear().domain([5, 25]).range(["hsl(220, 70%, 90%)", "hsl(220, 70%, 30%)"]).interpolate(d3.interpolateHsl);

	function speedToColor(d) {
		return speedToColorScale(d.s);
	}
	// Map a wind probability to a color
	var probabilityToColorScale = d3.scale.linear().domain([0, 0.2]).range(["hsl(0, 70%, 99%)", "hsl(0, 70%, 40%)"]).interpolate(d3.interpolateHsl);

	function probabilityToColor(d) {
		return probabilityToColorScale(d.p);
	}
	// Map a wind probability to an outer radius for the chart
	var probabilityToRadiusScale = d3.scale.linear().domain([0, 0.15]).range([34, visWidth - 20]).clamp(true);

	function probabilityToRadius(d) {
		return probabilityToRadiusScale(d.p);
	}
	// Map a wind speed to an outer radius for the chart
	var speedToRadiusScale = d3.scale.linear().domain([0, 20]).range([34, visWidth - 20]).clamp(true);

	function speedToRadius(d) {
		return speedToRadiusScale(d.s);
	}

	// Options for drawing the complex arc chart
	var windroseArcOptions = {
		width: 5,
		from: 34,
		to: probabilityToRadius
	}
	var windspeedArcOptions = {
		width: 5,
		from: 34,
		to: speedToRadius
	}
	
	
	// Draw a complete wind rose visualization, including axes and center text
	function drawComplexArcs(parent, plotData, colorFunc, arcTextFunc, complexArcOptions, arcTextT) {
		// Draw the main rose arcs
		parent.append("svg:g").attr("class", "arcs").selectAll("path").data(plotData.dirs).enter().append("svg:path").attr("d", arc(complexArcOptions)).style("fill", colorFunc).attr("transform", "translate(" + visWidth + "," + visWidth + ")").append("svg:title").text(function(d) {
			return d.d + "\u00b0 " + (100 * d.p).toFixed(1) + "% " + d.s.toFixed(0) + "kts"
		});

		// Add the calm wind probability in the center
//		var cw = parent.append("svg:g").attr("class", "calmwind").selectAll("text").data([plotData.calm.p]).enter();
//		cw.append("svg:text").attr("transform", "translate(" + visWidth + "," + visWidth + ")").text(function(d) {
//			return Math.round(d * 100) + "%"
//		});
//		cw.append("svg:text").attr("transform", "translate(" + visWidth + "," + (visWidth + 14) + ")").attr("class", "calmcaption").text("calm");
	}

	// Update the page text after the data has been loaded
	// Lots of template substitution here
	function updatePageText(d) {
		if (!('info' in d)) {
			// workaround for stations missing in the master list
			d3.selectAll(".stationid").text("????")
			d3.selectAll(".stationname").text("Unknown station");
			return;
		}
		document.title = "Wind History for " + d.info.id;
		d3.selectAll(".stationid").text(d.info.id);
		d3.selectAll(".stationname").text(d.info.name.toLowerCase());

		var mapurl = 'map.html#10.00/' + d.info.lat + "/" + d.info.lon;
		d3.select("#maplink").html('<a href="' + mapurl + '">' + d.info.lat + ', ' + d.info.lon + '</a>');
		d3.select("#whlink").attr("href", mapurl);

		var wsurl = 'http://weatherspark.com/#!dashboard;loc=' + d.info.lat + ',' + d.info.lon + ';t0=01/01;t1=12/31';
		d3.select("#wslink").attr("href", wsurl);
		var wuurl = 'http://www.wunderground.com/cgi-bin/findweather/getForecast?query=' + d.info.id;
		d3.select("#wulink").attr("href", wuurl);
		var vmurl = 'http://vfrmap.com/?type=vfrc&lat=' + d.info.lat + '&lon=' + d.info.lon + '&zoom=10';
		d3.select("#vmlink").attr("href", vmurl);
		var rfurl = 'http://runwayfinder.com/?loc=' + d.info.id;
		d3.select("#rflink").attr("href", rfurl);
		var nmurl = 'http://www.navmonster.com/apt/' + d.info.id;
		d3.select("#nmlink").attr("href", nmurl);
	}

	// Update all diagrams to the newly selected months
	function updateWindVisDiagrams(d) {
		updateBigWindrose(d, "#windrose");
		updateBigWindrose(d, "#windspeed");
	}

	// Update a specific digram to the newly selected months
	function updateBigWindrose(windroseData, container) {
		var vis = d3.select(container).select("svg");
		var rollup = rollupForMonths(windroseData, selectedMonthControl.selected());

		if (container == "#windrose") {
			updateComplexArcs(vis, rollup, speedToColor, speedText, windroseArcOptions, probArcTextT);
		} else {
			updateComplexArcs(vis, rollup, probabilityToColor, probabilityText, windspeedArcOptions, speedArcTextT);
		}
	}

	// Update drawn arcs, etc to the newly selected months
	function updateComplexArcs(parent, plotData, colorFunc, arcTextFunc, complexArcOptions, arcTextT) {
		// Update the arcs' shape and color
		parent.select("g.arcs").selectAll("path").data(plotData.dirs).transition().duration(200).style("fill", colorFunc).attr("d", arc(complexArcOptions));

		// Update the arcs' title tooltip
		parent.select("g.arcs").selectAll("path").select("title").text(function(d) {
			return d.d + "\u00b0 " + (100 * d.p).toFixed(1) + "% " + d.s.toFixed(0) + "kts"
		});
		// Update the calm wind probability in the center
		parent.select("g.calmwind").select("text").data([plotData.calm.p]).text(function(d) {
			return Math.round(d * 100) + "%"
		});
	}

	// Top level function to draw all station diagrams
	function makeWindVis(station) {
		var url = "data/" + station + ".json";
		var stationData = null;
		d3.json(url, function(d) {
			stationData = d;
			updatePageText(d);
			drawBigWindrose(d, "#windrose", "Frequency by Direction");
			drawBigWindrose(d, "#windspeed", "Average Speed by Direction");
			selectedMonthControl.setCallback(function() {
				updateWindVisDiagrams(d);
			});
		});

		selectedMonthControl = new monthControl(null);
		selectedMonthControl.install("#monthControlDiv");
	}

	// Draw a big wind rose, for the visualization
	function drawBigWindrose(windroseData, container, captionText) {
		// Various visualization size parameters
		var w = 400,
			h = 400,
			r = Math.min(w, h) / 2,
			// center; probably broken if not square
			p = 20,
			// padding on outside of major elements
			ip = 34; // padding on inner circle
		// The main SVG visualization element
		var vis = d3.select(container).append("svg:svg").attr("width", w + "px").attr("height", (h + 30) + "px");

		// Set up axes: circles whose radius represents probability or speed
		if (container == "#windrose") {
			var ticks = d3.range(0.025, 0.151, 0.025);
			var tickmarks = d3.range(0.05, 0.101, 0.05);
			var radiusFunction = probabilityToRadiusScale;
			var tickLabel = function(d) {
					return "" + (d * 100).toFixed(0) + "%";
				}
		} else {
			var ticks = d3.range(5, 20.1, 5);
			var tickmarks = d3.range(5, 15.1, 5);
			var radiusFunction = speedToRadiusScale;
			var tickLabel = function(d) {
					return "" + d + "kts";
				}
		}
		// Circles representing chart ticks
		vis.append("svg:g").attr("class", "axes").selectAll("circle").data(ticks).enter().append("svg:circle").attr("cx", r).attr("cy", r).attr("r", radiusFunction);
		// Text representing chart tickmarks
		vis.append("svg:g").attr("class", "tickmarks").selectAll("text").data(tickmarks).enter().append("svg:text").text(tickLabel).attr("dy", "-2px").attr("transform", function(d) {
			var y = visWidth - radiusFunction(d);
			return "translate(" + r + "," + y + ") "
		})
		// Labels: degree markers
		vis.append("svg:g").attr("class", "labels").selectAll("text").data(d3.range(30, 361, 30)).enter().append("svg:text").attr("dy", "-4px").attr("transform", function(d) {
			return "translate(" + r + "," + p + ") rotate(" + d + ",0," + (r - p) + ")"
		}).text(function(dir) {
			return dir;
		});

		var rollup = rollupForMonths(windroseData, selectedMonthControl.selected());
  	if (container == "#windrose") {
			drawComplexArcs(vis, rollup, speedToColor, speedText, windroseArcOptions, probArcTextT);
		} else {
			drawComplexArcs(vis, rollup, probabilityToColor, probabilityText, windspeedArcOptions, speedArcTextT);
		}
		vis.append("svg:text").text(captionText).attr("class", "caption").attr("transform", "translate(" + w / 2 + "," + (h + 20) + ")");
	}

	/** Code for small wind roses **/

	// Plot a small wind rose with the specified percentage data
	// parent: the SVG element to put the plot on
	// plotData: a list of 12 months, each a list of 13 numbers. plotData[month][0] is winds calm percentage,
	// plotData[month][1, 2, 3...] is percentage of winds at 30 degrees, 60, 90, ...
	var smallArcScale = d3.scale.linear().domain([0, 0.15]).range([5, 30]).clamp(true)
	var smallArcOptions = {
		width: 15,
		from: 5,
		to: function(d) {
			return smallArcScale(d.p);
		}
	}

	function plotSmallRose(parent, plotData) {
		var winds = [];
		var months = selectedMonthControl.selected();
		// For every wind direction (note: skip plotData[0], winds calm)
		for (var dir = 1; dir < 13; dir++) {
			// Calculate average probability for all selected months
			var n = 0;
			sum = 0;
			for (var month = 0; month < 12; month++) {
				if (months[month]) {
					n += 1;
					sum += plotData[month][dir];
				}
			}
			var avg = sum / n;
			winds.push({
				d: dir * 30,
				p: avg / 100
			});
		}
		parent.append("svg:g").selectAll("path").data(winds).enter().append("svg:path").attr("d", arc(smallArcOptions));
		parent.append("svg:circle").attr("r", smallArcOptions.from);
	}

</script>
